<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://github.com/qmacro/thinking-aloud</id>
    <title>Thinking Aloud</title>
    <updated>2021-04-07T08:07:35.100Z</updated>
    <generator>NPM module feed (https://www.npmjs.com/package/feed)</generator>
    <author>
        <name>DJ Adams</name>
        <email>qmacro@gmail.com</email>
        <uri>https://github.com/qmacro</uri>
    </author>
    <link rel="alternate" href="https://github.com/qmacro/thinking-aloud"/>
    <link rel="self" href="https://github.com/qmacro/thinking-aloud"/>
    <subtitle>A journal</subtitle>
    <rights>DJ Adams</rights>
    <entry>
        <title type="html"><![CDATA[2021-04-07 09:04:01]]></title>
        <id>https://github.com/qmacro/thinking-aloud/issues/15</id>
        <link href="https://github.com/qmacro/thinking-aloud/issues/15"/>
        <updated>2021-04-07T08:07:23.000Z</updated>
        <content type="html"><![CDATA[<p>Does it make sense to create a workflow to clean up old workflow runs?</p>
<p>I'm using my dwr script right now to clean up some of the workflow runs in my repositories. It got me thinking - what about an automatic cleanup? Would it make sense to write a workflow … to delete old workflow runs on a regular basis? There's a sort of pleasant balance in there as well, in that eventually, the runs from these cleanup workflows would be themselves cleaned up too.</p>
<p>In case you're interested in the <code>dwr</code> script as it stands right now, you can find it <a href="https://github.com/qmacro/dotfiles/blob/master/scripts/dwr">here</a> in my dotfiles.</p>
<p>What do you think? Is it worth following this thought to an experimental cleanup workflow definition? What would that look like?</p>]]></content>
        <category label="entry"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021-03-25 16:39:40]]></title>
        <id>https://github.com/qmacro/thinking-aloud/issues/13</id>
        <link href="https://github.com/qmacro/thinking-aloud/issues/13"/>
        <updated>2021-03-25T17:04:24.000Z</updated>
        <content type="html"><![CDATA[<p>I love the "Today I Learned" (TIL) idea, and even have a TIL style blog called <a href="https://qmacro.org/autodidactics/">autodidactics</a>. That said, I'm wondering if there's also value in reifying what might be the other side of the TIL coin, i.e. the "Want To Learn" (WTL) idea.</p>
<p>There are plenty of things that I wish I knew, from understanding specific concepts, to being able to achieve specific goals. At the very small end of the "achieve specific goals" stage there's Stack Overflow to give me answers, and that's fine. But sometimes I don't want the answer on a plate, I want to work for it, as - if time permits - the journey of effort is often fun and nearly always rewarding.</p>
<p>Here's an example:</p>
<ul>
<li>WTL the best way to mass-delete logs from GitHub Actions workflow runs</li>
</ul>
<p>I've read somewhere that right now it's not possible from the Actions web interface, so I'm guessing the answer might be in the use of one or more API endpoints. I know that going from where I am now to understanding how to do it will improve my knowledge and be useful too.</p>
<p>The essence of this WTL is that it's tangible and I'll know when I've flipped it into a TIL. I know that some of the other stuff I wish I knew is less like that (grokking specific technical concepts) but not everything is black and white.</p>
<p>I think that now I have given a name to this type of thought ("how do I do / understand that?") that swirl around my brain, bumping into and otherwise disturbing what I'm actually trying to think about, it will help. I can capture the thought as a WTL and move on.</p>
<p>Now, where are those GitHub API docs?</p>]]></content>
        <category label="entry"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021-03-25 12:09:25]]></title>
        <id>https://github.com/qmacro/thinking-aloud/issues/9</id>
        <link href="https://github.com/qmacro/thinking-aloud/issues/9"/>
        <updated>2021-03-25T12:19:09.000Z</updated>
        <content type="html"><![CDATA[<p>What else do I need for the basic setup of my journalling here with Thinking Aloud?</p>
<p>On the one hand, I don't want to over-complicate things - part of the idea is to have a minimal setup. On the other hand, there are probably aspects that I'm still missing.</p>
<p>One in particular is the ability to "go meta". In other words, I want to be able to raise issues for the repo-based journalling mechanism itself, so I can record something that's amiss and then get around to addressing that.</p>
<p>But while I'm using issues in the simplest possible way, that's not going to work, as I'll pick up those "real" issues too in my journalling output. So it's time to turn to labels. I've alluded to the use of labels, which can be assigned to issues on GitHub, and while I was thinking more about journal entry categories, I really need a label to distinguish actual journal entries from non-journal entries.</p>
<p>I was originally thinking of having a label for non-journal entries, such as "issue", but that seems a little silly; better to have a positive "entry" label, as I can easily add that to my "new journal entry" mechanism - the <code>gh</code> GitHub CLI lets me assign labels on issue creation, <a href="https://cli.github.com/manual/gh_issue_create">like this</a>:</p>
<pre><code class="shell language-shell">; gh issue create --label entry --title "..."
</code></pre>
<p>Then it's easy to show the list of actual journal entry issues, using the very capable <a href="https://docs.github.com/en/github/searching-for-information-on-github/searching-issues-and-pull-requests">search & filter syntax</a>. I think this is what I'll implement next, and then I can record this sort of "missing feature" entry as an actual issue rather than an entry.</p>]]></content>
        <category label="entry"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021-03-25 09:53:26]]></title>
        <id>https://github.com/qmacro/thinking-aloud/issues/7</id>
        <link href="https://github.com/qmacro/thinking-aloud/issues/7"/>
        <updated>2021-03-25T10:13:52.000Z</updated>
        <content type="html"><![CDATA[<p>Some thoughts on learning, and how I pick the topics. </p>
<p>Starting from a <a href="https://twitter.com/alexellisuk/status/1374657364813619201">tweet from Alex Ellis on learning & age</a>, in one of the ensuing threads, Jeroen Jacobs described the challenges of learning while working, and the challenge of that learning being non-billable and / or fleeting due to lack of opportunities to practise.</p>
<p>I've been a life long learner, not initially consciously by any means, but, helped by my <a href="https://blogs.sap.com/2018/10/01/monday-morning-thoughts-impostor-syndrome/">impostor syndrome</a> I've always strived to flesh out my knowledge and remain above water. With computing in general, and enterprise computing in particular, I've found that it was usually natural to discover related topics that I had little idea about.</p>
<p>So those were the natural targets for new learning efforts. Not only because I could relate to them because they were to some degree relevant to the task at hand, but also because I had started to figure out that the more I knew about those related topics, the greater my overall understanding of things and the more useful I became.</p>
<p>To take an example - in the early days of APIs, when we started to move beyond the proprietary protocols and approaches (such as remote function calls and the RFC SDK), it was HTTP that sat firmly front and centre as the protocol around which the API world was beginning to revolve. While I could have got by with just a shallow understanding of HTTP, enough to create, make and debug API calls, I dove right in, to the extent that I call <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> a friend. Moreover, that journey led me to properly understand that HTTP is an <em>application</em> protocol, which in turn helped me understand why the whole Web Services Deathstar was destined from birth for self-destruction, because it was built on false foundations (the abuse of HTTP as a <em>transport</em> protocol). And of course, those investigations led me to Roy Fielding's thesis and the concepts of Representational State Transfer (REST), which -- to an extent -- underpins much of the API surface area today.</p>
<p>In my journey of discovery here, everything I did eventually became relevant to my work. Not by chance, but, I think, by relation.</p>
<p>So now where do I go with that? Well, while I'm not yet using GraphQL (except for an experiment with GitHub's API surface), I have at least <a href="https://blogs.sap.com/2018/09/03/monday-morning-thoughts-considering-graphql/">looked into it</a>, at least enough for now to understand how it differs from, say, RESTful approaches, and, as <a href="https://en.wikipedia.org/wiki/Nigel_Molesworth">Molesworth</a> might say, in a "kno yore enemie" kind of way. And I do know that GraphQL most likely <em>will</em> feature in my future, so it's something I'll look into.</p>
<p>Anyway, what am I saying here? I think I'm saying that there's a semi-conscious filtering that goes on in my head when it comes to continuous learning; filtering that is designed to protect me from burnout, from learning stuff that I'll never get a chance to practise, but most of all to take advantage of a key aspect of learning - helping me to build the next layer of understanding.</p>
<p>An additional thought here relates to the need for practice. Jeroen <a href="https://twitter.com/JeroenJacobs79/status/1374977310491836420">commented</a>:</p>
<blockquote>
  <p>… the things I learn outside business hours, well it seems I forget most of it if I don't apply it during the work day</p>
</blockquote>
<p>This reminded me of a great conversation between Scott Hanselman and Romain Goyet on a new pocket calculator, in the Hanselminutes podcast episode <a href="https://hanselminutes.com/779/its-time-for-a-new-kind-of-calculator-with-numworks-romain-goyet">It's time for a new kind of calculator with NumWorks' Romain Goyet</a>. Romain talked about energy consumption and eventual battery drain in devices, and drew out the distinction between dynamic RAM and static RAM. </p>
<p>I think our minds are a lot like dynamic RAM, in that they need to be regularly refreshed (perhaps not as frequently as dynamic RAM!) with the same information, lest that information loses synaptic relevance and fades away. </p>]]></content>
        <category label="entry"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021-03-24 15:44:46]]></title>
        <id>https://github.com/qmacro/thinking-aloud/issues/2</id>
        <link href="https://github.com/qmacro/thinking-aloud/issues/2"/>
        <updated>2021-03-24T16:00:34.000Z</updated>
        <content type="html"><![CDATA[<p>So I've got the bare minimum set up for this journal, in the <a href="https://github.com/qmacro/thinking-aloud">thinking-aloud</a> repository:</p>
<ul>
<li>issues to contain my journal entries, and possibly conversations about them (via the comments)</li>
<li>a simple <a href="https://github.com/qmacro/thinking-aloud/blob/main/feed">Atom feed generator</a> that will build an Atom 1.0 feed from a JSON list of issues that I can retrieve from the GitHub API - the feed's URL is <a href="https://raw.githubusercontent.com/qmacro/thinking-aloud/main/feed.xml">https://raw.githubusercontent.com/qmacro/thinking-aloud/main/feed.xml</a></li>
<li>labels that I can assign to the issues for eventual categorisation (I have <a href="https://github.com/qmacro/thinking-aloud/blob/08bf3f98064237c35b3bf7ae4fb16b5ecb9608b6/feed#L44">made provision for this in the feed generator already</a></li>
<li>a GitHub Actions <a href="https://github.com/qmacro/thinking-aloud/actions/workflows/generate-feed.yml">workflow</a> that is triggered when an issue is created or edited and causes the feed to be rebuilt</li>
</ul>
<p>This was a pleasant few hours messing around on a day off. Well, I say pleasant, there was one unpleasant part which was trying (and failing) to parse and use the output from the <a href="https://github.com/octokit/request-action">octokit/request-action</a>.</p>
<p>The silver lining in this though is that I realised that I could just use the <code>gh</code> CLI, as long as I supply the <code>GITHUB_TOKEN</code> env var with the appropriate (and auto-generated) secret value, <a href="https://github.com/qmacro/thinking-aloud/blob/a8fda4c7705d26a30d47001885e6f20d4669a987/.github/workflows/generate-feed.yml#L21-L27">like this</a>:</p>
<pre><code class="yaml language-yaml">- name: Generate feed
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  run: |
    gh api "/repos/${GITHUB_REPOSITORY}/issues?sort=created&amp;direction=descending" \
      | ./feed \
      | tee feed.xml
</code></pre>
<p>If you're interested in following these journal entries, add the feed URL to your favourite feed reader: <a href="https://raw.githubusercontent.com/qmacro/thinking-aloud/main/feed.xml">https://raw.githubusercontent.com/qmacro/thinking-aloud/main/feed.xml</a>, and if you want to comment on any of the entries, you can do so in the comments to the corresponding issue.</p>]]></content>
        <category label="entry"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021-03-24 10:55:54]]></title>
        <id>https://github.com/qmacro/thinking-aloud/issues/1</id>
        <link href="https://github.com/qmacro/thinking-aloud/issues/1"/>
        <updated>2021-03-24T11:03:40.000Z</updated>
        <content type="html"><![CDATA[<p>Can't help overthinking what I should have as my first entry in this journal. Reminds me of the feeling of starting a new notebook, and agonising over what should be on the first page - it must be neat and permanently relevant. Of course, that's nonsense.</p>
<p>So I thought I'd just start typing. After all, the idea of this journal is to allow me to record thoughts in as friction-free a way as possible. Part of that is having a low barrier to writing, but also a low filter threshold.</p>
<p>Anyway, as usual, I've spent the last hour yak shaving, setting up a little system where I can just hit <code>j</code> and get directly to typing in my thoughts.</p>
<p>Hitting <code>j</code> starts a new <code>tmux</code> 'JOURNAL' session, or attaches to an existing one, and then uses <code>gh issue create</code> to initiate the process. The title is easy - I wanted to avoid having to think about what I should title each journal entry, so I'm simply using a timestamp. The <code>gh issue create</code> process then takes me into <code>vim</code> whereupon some <code>vim</code> configuration notices that it's a Markdown buffer that I'm editing, and throws me into <code>Goyo</code> which is a fantastic way to focus on writing.</p>
<p>And that's it. I'm not exactly sure whether things will work when I exit this buffer, I guess the only way to find out is to try it. Here goes.</p>]]></content>
        <category label="entry"/>
    </entry>
</feed>
